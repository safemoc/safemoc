# 内存泄露
l1 = [1, 2, 3]
l2 = [3, 4, 5]
l1.append(l2)
l2.append(l1)
'''
将l2添加到l1的末尾 再将l1添加到l2的末尾
互相引用,你中有我我中有你
'''
del l1
'''
并不是删除l1 只是擦除了 l1与内存空间的引用关系
这时候,原本l1 列表的引用计数并没有归零 在l2中还有间接引用
'''
del l2
'''
同样擦除了 l2 与内存空间的引用关系
可是这时候,l2原本的列表的引用关系 还有l1原本的列表的间接引用
可是我们无法调用这两个列表,因为我们已经擦除了这两个列表与变量名的 直接引用
它们身上只有它们身上的相互引用,我们也无法取到这两个列表
因为引用没有归零 所以垃圾回收机制无法回收 这两个列表
这就是内存泄露 在开发过程中这种情况是禁止的,python也提供了一种方案 
'''
# 标记清除
'''
首先需要了解变量名是存在哪里的
在内存中 有两个部分 一个是栈区 一个是堆区 
栈区负责存储变量名,堆区负责存储数据
当定义一个变量 a ='a' 的时候
会在堆区开辟空间存储数据,并在栈区开辟空间存储变量名 对应上堆区的内存地址
当堆区的引用计数为0 被清除时,对应栈区的变量名也被清除
回到循环引用的案例:
声明一个l1 l2
 l1的堆区有l2的堆区的内存地址 (间接引用)
 l2的堆区有l1的堆区的内存地址 (间接引用)
 
 执行del 时 实际执行的是 擦除栈区 变量名对堆区的数据的直接引用
 执行 del l1,l2
 栈区 l1 l2 与堆区 的数据没有引用了,但是堆区的数据在相互间接引用
 当python 内存空间不够用的时候 会暂停整个程序 扫描栈区 把栈区可以引用到的值标记为存活状态(不管直接引用还是间接引用)
 发现栈区有引用不到的值,就会标记为死亡状态 死亡状态的值会被直接清理掉 就算身上的引用计数不为0 只要访问不到 就会标记为垃圾被回收
'''
# 举例
# 出门遛狗没拴绳,被城管发现,狗就会被回收


'''
通过垃圾回收 以及 标记清除 已经可以回收所有垃圾了
目前还有一个弊端 
基于引用计数的回收机制,每次回收 都需要将所有对象的引用计数遍历一遍
当变量很多的时候 效率就会变低
python 使用了分代回收机制:
将变量标记为三种状态:G0-G1-G2
对象刚刚创建的时候为G0 扫描存活下来的话,就移至G1扫描次数就会减少
G2 扫描次数会更少
'''

# 可变与不可变类型
# 可变类型:值改变的情况下 id 不变,说明改变的是内存中的值
list;dict;set;
# 不可变类型: 值改变的情况下,id也变了,说明是产生了新的值对应了新的内存空间
int;float;str;bool;tuple;frozenset;
'字典中的key 只要是不可变类型都可以做为key'
